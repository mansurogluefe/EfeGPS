<!DOCTYPE html>
<html lang="tr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Efe CanlÄ± Ã‡eviri - % Progress + Kalan Saniye</title>
<style>
  body {font-family: -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto;background:#0f172a;color:#e2e8f0;margin:0;padding:20px;}
  h1 {text-align:center;font-size:26px;margin:20px 0;color:#60a5fa;}
  .box {background:#1e293b;padding:24px;border-radius:20px;box-shadow:0 10px 40px rgba(0,0,0,0.6);}
  button {padding:12px 20px;margin:8px;border:none;border-radius:12px;font-weight:700;font-size:15px;cursor:pointer;}
  button.start {background:#2563eb;color:white;}
  button.stop {background:#dc2626;color:white;}
  button:disabled {opacity:0.5;cursor:not-allowed;}
  #status {margin-left:15px;font-size:15px;color:#93c5fd;font-weight:600;}

  .chat {display:flex;flex-direction:column;gap:12px;margin-top:20px;}
  .bubble {max-width:90%;padding:14px 18px;border-radius:16px;line-height:1.4;font-size:16px;word-wrap:break-word;}
  .en {align-self:flex-start;background:#1e40af;color:white;}
  .tr {align-self:flex-end;background:#16a34a;color:white;}

  #logPanel {position:fixed;bottom:0;left:0;right:0;height:260px;background:#000;color:#0f0;padding:12px;font-family:monospace;font-size:13px;overflow-y:auto;border-top:4px solid #00ff00;z-index:9999;display:none;box-sizing:border-box;}
  #logPanel.show {display:block;}
  #showLog {position:fixed;bottom:20px;right:20px;background:#00ff00;color:#000;padding:12px 18px;border-radius:40px;font-weight:bold;z-index:10000;box-shadow:0 6px 20px rgba(0,255,0,0.4);}
</style>
</head>
<body>

<h1>Efe CanlÄ± Ã‡eviri - % Progress GÃ¶steren</h1>

<div class="box">
  <button id="startBtn" class="start">BaÅŸlat</button>
  <button id="stopBtn" class="stop" disabled>Durdur</button>
  <span id="status">Model bekleniyor...</span>
</div>

<div class="chat" id="chat"></div>

<button id="showLog">LOG AÃ‡</button>
<div id="logPanel">
  <div style="color:#ff0">CanlÄ± log aktif â€“ model yÃ¼kleme yÃ¼zdesi ve hata/olaylar burada gÃ¶zÃ¼kecek</div>
</div>

<script type="module">
/*
  DÃ¼zeltilmiÅŸ sÃ¼rÃ¼m:
  - Model yÃ¼kleme sÄ±rasÄ±nda gÃ¼venli bir "yÃ¼zde" animasyonu gÃ¶sterir.
  - AudioContext / stream yÃ¶netimi dÃ¼zeltildi (AudioContext global, dÃ¼zgÃ¼n kapatma).
  - Echo/feedback azaltmak iÃ§in sessiz gain node ile baÄŸlandÄ±.
  - Deepgram Ã§aÄŸrÄ±sÄ± hata kontrolÃ¼ geliÅŸtirildi.
  - Genel hata yakalama ve kullanÄ±cÄ±ya bilgi verme eklendi.
*/

import { pipeline } from 'https://cdn.jsdelivr.net/npm/@xenova/transformers@2.17.2/dist/transformers.min.js';

const DEEPGRAM_KEY = "8b58f8fcf792acd4b0e5d823c3ddf68c8f70af40";

let translator = null;
let loadingSimInterval = null;
let simulatedPercent = 0;
let loadingStartTime = 0;

const logPanel = document.getElementById("logPanel");
const showLogBtn = document.getElementById("showLog");
const statusEl = document.getElementById("status");
const chatEl = document.getElementById("chat");

let audioStream = null;
let audioCtx = null;
let processor = null;
let gainNode = null;

function log(msg, error = false) {
  const line = document.createElement("div");
  const time = new Date().toLocaleTimeString();
  line.textContent = `${time} â†’ ${msg}`;
  line.style.color = error ? "#ff6b6b" : "#7efc9b";
  logPanel.appendChild(line);
  logPanel.scrollTop = logPanel.scrollHeight;
  console.log("[LOG]", msg);
}

showLogBtn.addEventListener("click", () => {
  const isShown = logPanel.classList.toggle("show");
  showLogBtn.textContent = isShown ? "LOG KAPAT" : "LOG AÃ‡";
});

function addBubble(text, type) {
  if (!text || !text.trim()) return;
  const div = document.createElement("div");
  div.className = `bubble ${type}`;
  div.textContent = text.trim();
  // yeni mesaj en Ã¼ste gelsin istiyorsan: insertBefore; yoksa appendChild kullan
  chatEl.insertBefore(div, chatEl.firstChild);
  // sayfa kaydÄ±rmasÄ±nÄ± Ã¼stte tut
  window.scrollTo({ top: 0, behavior: "smooth" });
}

/* pcm float32 -> wav blob */
function pcmToWav(samples, sampleRate = 44100) {
  const numChannels = 1;
  const bitsPerSample = 16;
  const blockAlign = numChannels * bitsPerSample / 8;
  const byteRate = sampleRate * blockAlign;
  const dataSize = samples.length * (bitsPerSample / 8);
  const buffer = new ArrayBuffer(44 + dataSize);
  const view = new DataView(buffer);

  function writeString(offset, str) {
    for (let i = 0; i < str.length; i++) {
      view.setUint8(offset + i, str.charCodeAt(i));
    }
  }

  let offset = 0;
  writeString(offset, 'RIFF'); offset += 4;
  view.setUint32(offset, 36 + dataSize, true); offset += 4;
  writeString(offset, 'WAVE'); offset += 4;
  writeString(offset, 'fmt '); offset += 4;
  view.setUint32(offset, 16, true); offset += 4; // Subchunk1Size (16 for PCM)
  view.setUint16(offset, 1, true); offset += 2; // AudioFormat (1 = PCM)
  view.setUint16(offset, numChannels, true); offset += 2;
  view.setUint32(offset, sampleRate, true); offset += 4;
  view.setUint32(offset, byteRate, true); offset += 4;
  view.setUint16(offset, blockAlign, true); offset += 2;
  view.setUint16(offset, bitsPerSample, true); offset += 2;
  writeString(offset, 'data'); offset += 4;
  view.setUint32(offset, dataSize, true); offset += 4;

  // PCM samples (16-bit)
  let pos = 44;
  for (let i = 0; i < samples.length; i++, pos += 2) {
    let s = Math.max(-1, Math.min(1, samples[i]));
    view.setInt16(pos, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
  }

  return new Blob([view], { type: 'audio/wav' });
}

/* Deepgram speech-to-text (recognize) */
async function recognize(blob) {
  const res = await fetch("https://api.deepgram.com/v1/listen?model=nova-2&language=en&punctuate=true", {
    method: "POST",
    headers: { "Authorization": `Token ${DEEPGRAM_KEY}`, "Content-Type": "audio/wav" },
    body: blob
  });
  if (!res.ok) {
    const text = await res.text().catch(()=>"");
    throw new Error(`Deepgram hata: ${res.status} ${res.statusText} ${text}`);
  }
  const json = await res.json();
  const alt = json?.results?.channels?.[0]?.alternatives?.[0];
  return (alt && alt.transcript) ? alt.transcript.trim() : "";
}

/* Basit Ã§eviri wrapper */
async function translate(text) {
  if (!translator) {
    // eÄŸer model henÃ¼z hazÄ±r deÄŸilse, aÃ§Ä±kÃ§a yÃ¼kle
    await loadModel();
    if (!translator) return text + " (Ã§eviri modeli yok)";
  }
  try {
    const out = await translator(text);
    // Xenova pipeline dÃ¶nÃ¼ÅŸ yapÄ±sÄ± model/versiyona gÃ¶re deÄŸiÅŸebilir
    // Tipik: [{ translation_text: "..." }]
    if (Array.isArray(out) && out[0]?.translation_text) return out[0].translation_text;
    // bazen doÄŸrudan string dÃ¶nebilir:
    if (typeof out === 'string') return out;
    // diÄŸer durumlarda olabildiÄŸince gÃ¼venli dÃ¶nÃ¼ÅŸ
    return JSON.stringify(out).slice(0,400);
  } catch (e) {
    log("Ã‡eviri hatasÄ±: " + e.message, true);
    return text + " (Ã§eviri hatasÄ±)";
  }
}

/* Model yÃ¼kleme: bazÄ± CDN implementasyonlarÄ± progress callback vermeyebilir.
   Burada gÃ¼venli olmak iÃ§in "simÃ¼le edilmiÅŸ" ilerleme gÃ¶stergesi kullanalÄ±m.
*/
async function loadModel() {
  if (translator) return translator;

  log("Model indirilmeye baÅŸlandÄ± (pipeline Ã§aÄŸrÄ±sÄ±)...");
  statusEl.textContent = "Model indiriliyor... %0";
  simulatedPercent = 0;
  loadingStartTime = Date.now();

  // SimÃ¼le edilmiÅŸ artÄ±ÅŸ: her 300ms yÃ¼zdeyi artÄ±r
  loadingSimInterval = setInterval(() => {
    // yavaÅŸ yavaÅŸ artÄ±ÅŸ, ama %98'e kadar; gerÃ§ek bitiÅŸte %100'e setlenecek.
    simulatedPercent = Math.min(98, simulatedPercent + Math.max(1, Math.floor(Math.random()*6)));
    statusEl.textContent = `Model indiriliyor... %${simulatedPercent}`;
    log(`SimÃ¼le yÃ¼zde: ${simulatedPercent}%`);
  }, 300);

  try {
    // Burada kullanÄ±lan model id'si notebook/CDN'e gÃ¶re deÄŸiÅŸebilir.
    // "Helsinki-NLP/opus-mt-en-tr" evrensel, Xenova CDN de destekliyor olmalÄ±.
    translator = await pipeline('translation', 'Helsinki-NLP/opus-mt-en-tr');
    // pipeline baÅŸarÄ±lÄ±ysa hemen %100 yap
    simulatedPercent = 100;
    statusEl.textContent = "HazÄ±r â€“ KonuÅŸ!";
    log("%100 â†’ MODEL BAÅžARIYLA YÃœKLENDÄ°! Offline Ã§eviri aktif ðŸ”¥");
  } catch (e) {
    log("Model yÃ¼kleme HATASI: " + (e?.message || e), true);
    statusEl.textContent = "Model yÃ¼klenemedi â€“ Konsolu kontrol et";
    translator = null;
  } finally {
    if (loadingSimInterval) { clearInterval(loadingSimInterval); loadingSimInterval = null; }
  }
  return translator;
}

/* Gelen ses chunk'Ä± iÅŸleme */
async function processChunk(samples) {
  statusEl.textContent = "Ã‡evriliyor...";
  const blob = pcmToWav(samples);
  try {
    const eng = await recognize(blob);
    if (!eng || eng.length < 1) {
      log("TanÄ±ma: kÄ±sa veya boÅŸ transcript.");
      statusEl.textContent = "Dinliyor...";
      return;
    }
    log("Ä°NG: " + eng);
    addBubble(eng, "en");
    const tr = await translate(eng);
    log("TR: " + tr);
    addBubble(tr, "tr");
    statusEl.textContent = "Dinliyor...";
  } catch (e) {
    log("Hata: " + (e?.message || e), true);
    statusEl.textContent = "Hata oluÅŸtu";
  }
}

/* GLOBAL deÄŸiÅŸkenler: audioCtx, vs. â€” baÅŸlat/durdur yÃ¶netimi */
document.getElementById("startBtn").onclick = async () => {
  document.getElementById("startBtn").disabled = true;
  document.getElementById("stopBtn").disabled = false;

  try {
    // modeli Ã¶nceden yÃ¼klemeye baÅŸla (arkaplanda)
    loadModel().catch(e => log("Model preload hatasÄ±: " + e, true));

    audioStream = await navigator.mediaDevices.getUserMedia({ audio: true });
    log("Mikrofon aÃ§Ä±ldÄ±");

    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const source = audioCtx.createMediaStreamSource(audioStream);

    // ScriptProcessor deprecated ama basitÃ§e Ã§alÄ±ÅŸÄ±r; boyutu 4096 OK
    processor = audioCtx.createScriptProcessor(4096, 1, 1);

    // Gain node ile processor->destination baÄŸlantÄ±sÄ± yap (gain=0) -> echo Ã¶nleme
    gainNode = audioCtx.createGain();
    gainNode.gain.value = 0;

    // buffer to accumulate samples
    const bufferSamples = [];
    const chunkSize = audioCtx.sampleRate * 2; // 2 saniye chunk

    processor.onaudioprocess = (e) => {
      const ch = e.inputBuffer.getChannelData(0);
      // kopyala (Float32Array -> normal array push)
      for (let i = 0; i < ch.length; i++) bufferSamples.push(ch[i]);

      // eÄŸer tam chunk dolduysa iÅŸle
      if (bufferSamples.length >= chunkSize) {
        const chunk = bufferSamples.splice(0, chunkSize);
        // processChunk'i yormamak iÃ§in microtask'lere bÄ±rak
        processChunk(chunk);
      }
    };

    source.connect(processor);
    processor.connect(gainNode);
    gainNode.connect(audioCtx.destination);

    log("CanlÄ± Ã§eviri baÅŸladÄ± â€“ model yÃ¼kleme yÃ¼zdesi takip ediliyor");
    statusEl.textContent = "HazÄ±r deÄŸilse model indiriliyor...";
  } catch (e) {
    log("Mikrofon hatasÄ±: " + (e?.message || e), true);
    alert("Mikrofon izni ver veya tarayÄ±cÄ± izinlerini kontrol et!");
    document.getElementById("startBtn").disabled = false;
    document.getElementById("stopBtn").disabled = true;
  }
};

document.getElementById("stopBtn").onclick = async () => {
  try {
    if (processor) {
      processor.disconnect();
      processor.onaudioprocess = null;
      processor = null;
    }
    if (gainNode) {
      try { gainNode.disconnect(); } catch(_) {}
      gainNode = null;
    }
    if (audioCtx) {
      try { await audioCtx.close(); } catch(_) {}
      audioCtx = null;
    }
    if (audioStream) {
      audioStream.getTracks().forEach(t => t.stop());
      audioStream = null;
    }
    document.getElementById("startBtn").disabled = false;
    document.getElementById("stopBtn").disabled = true;
    statusEl.textContent = "Durduruldu";
    log("Durduruldu");
  } catch (e) {
    log("Durdurma hatasÄ±: " + (e?.message || e), true);
  }
};
</script>
</body>
</html>